# Copyright 2014 Schuberg Philis
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.

import collections
import json
import yaml
import os
import urllib
import subprocess

from oslo.config import cfg

from cloudbaseinit.openstack.common import log as logging
from cloudbaseinit.plugins import base

opts = [
    cfg.StrOpt('node_name',
               default=None,
               help='Node name of the machine to find or register with chef. '
                    'This is used as a fallback if we cannot get the host name '
                    'from the cloud service.'),
    cfg.StrOpt('chef_server_url',
               default=None,
               help='URL of the chef server to use. Should include '
                    'organization/$org_name for enterprise chef.'),
    cfg.StrOpt('msi_url',
               default=None,
               help='URL to download the chef client MSI from. '
                    'This is used as a fallback if we cannot get msi_url from the '
                    'user data. '
                    'If it is not found or specified, chef will not be installed.'),
    cfg.StrOpt('validation_client_name',
               default=None,
               help='Name of the validator to use to register the machine. '
                    'This is used as a fallback if we cannot get validation_name from the '
                    'user data. '
                    'If it is not found or specified, the machine will not be registered.'),
    cfg.StrOpt('validation_cert',
               default=None,
               help='PEM encoded string containing the validation key to use '
                    'to register the machine. '
                    'This is used as a fallback if we cannot get validation_cert from the '
                    'user data. '
                    'If it is not found or specified, the machine will not be registered.'),
    cfg.ListOpt('chef_run_list',
                default=None,
                help='List of recipes to run after chef is installed. '
                     'This is used as a fallback if we cannot get run_list from the '
                     'user data. '
                     'If it is not found or specified, the run list will be empty.'),
    cfg.StrOpt('chef_environment',
               default=None,
               help='Chef environment to put the node in. '
                    'This is used as a fallback if we cannot get chef_environment from the'
                    'user data. '
                    'If it is not found or specified, the machine will be in the '
                    '_default chef environment.'),
]

CONF = cfg.CONF
CONF.register_opts(opts)

LOG = logging.getLogger(__name__)

CHEF_BASE_DIR = "C:/chef"
CHEF_CONFIG = "C:/chef/client.rb"
CHEF_FIRST_BOOT = "C:/chef/first-boot.json"
CHEF_VALIDATION_KEY = "C:/chef/validation.pem"
RUBY_COMMAND = "C:/opscode/chef/embedded/bin/ruby.exe"
CHEF_COMMAND = "C:/opscode/chef/bin/chef-client"
CHEF_CONFIG_BASE = """
# This file was generated by the cloudbase-init chef plugin.
log_level              :info
ssl_verify_mode        :verify_none
log_location           "C:/chef/client.log"
client_key             "C:/chef/client.pem"
json_attribs           "C:/etc/chef/first-boot.json"
file_cache_path        "C:/chef/cache"
file_backup_path       "C:/chef/backup"
Chef::Log::Formatter.show_time = true
"""


class ChefBootstrapPlugin(base.BasePlugin):
    def __init__(self):
        self._user_data = {}
        self._node_name = None
        self._server_url = None
        self._msi_url = None
        self._validation_client_name = None
        self._validation_cert = None
        self._run_list = None
        self._environment = None
        self._initial_attributes = None

        super(ChefBootstrapPlugin, self).__init__()

    def _get_user_data(self, service):
        if len(self._user_data) > 0:
            return self._user_data
        if not hasattr(service, 'get_user_data'):
            LOG.info('Service does not provide user_data')
            return self._user_data
        user_data = service.get_user_data()
        if user_data is None:
            LOG.info('Service returned no user data')
        elif isinstance(user_data, collections.Mapping):
            self._user_data = user_data
        elif isinstance(user_data, basestring):
            if isinstance(user_data, str):
                user_data = user_data.decode('utf8')
            user_data = user_data.strip()
            if user_data == "":
                LOG.info('Service returned empty user data')
            else:
                try:
                    user_data = json.loads(user_data)
                    self._user_data = user_data
                except ValueError:
                    LOG.info('Could not load user_data as json:\n%s' % user_data)
                    try:
                        user_data = yaml.load(user_data)
                        self._user_data = user_data
                    except SyntaxError:
                        LOG.info('Could not load user_data as yaml')
        return self._user_data

    @staticmethod
    def _get_node_name(service):
        value = service.get_host_name()
        if not value:
            LOG.debug('cannot determine node_name from host name, trying config')
            value = CONF.node_name
            if not value:
                LOG.debug('no node_name in config either, not bootstrapping chef')
        return value

    def _get_user_data_value(self, service, name, default=None, required=False):
        user_data = self._get_user_data(service)
        value = user_data.get(name, None)
        if not value:
            LOG.debug('cannot determine %s from user data, trying config' % name)
            value = getattr(CONF, name, None)
            if not value:
                LOG.debug('no %s in config either' % name)
                if required:
                    LOG.debug('required parameter %s missing from user data and config' % name)
        if value is None:
            return default
        return value

    def _write_chef_config(self):
        LOG.debug('Writing chef client config to %s' % CHEF_CONFIG)
        with open(CHEF_CONFIG, 'w') as f:
            f.write(CHEF_CONFIG_BASE)
            if self._server_url:
                f.write("""
chef_server_url        "%s"
""" % self._server_url)
            if self._environment:
                f.write("""
environment            "%s"
""" % self._environment)
            if self._node_name:
                f.write("""
node_name              "%s"
""" % self._node_name)
            if self._validation_client_name:
                f.write("""
validation_client_name "%s"
""" % self._validation_client_name)
            if self._validation_cert:
                f.write("""
validation_key "%s"
""" % CHEF_VALIDATION_KEY)

    def _write_first_boot_json(self):
        first_boot = {
            'run_list': self._run_list
        }
        if self._initial_attributes is not None:
            first_boot['initial_attributes'] = self._initial_attributes
        json_str = json.dumps(first_boot, ensure_ascii=True, indent=4)
        LOG.debug('Writing first boot JSON to %s' % CHEF_FIRST_BOOT)
        with open(CHEF_FIRST_BOOT, 'w') as f:
            f.write(json_str)
            f.write("\n")

    @staticmethod
    def _is_chef_installed():
        return os.path.isfile(CHEF_COMMAND)

    def _write_validation_cert(self):
        if self._validation_cert is None:
            LOG.debug('Not writing validation key, no cert found')
            return
        LOG.debug('Writing validation key to %s' % CHEF_VALIDATION_KEY)
        with open(CHEF_VALIDATION_KEY, 'w') as f:
            f.write(self._validation_cert)

    @staticmethod
    def _install_msi(filename):
        LOG.debug('Installing %s' % filename)
        subprocess.check_call(['msiexec', '/i', filename, '/quiet'], shell=True)

    def _install_chef(self):
        if self._msi_url is None:
            LOG.debug('Not installing chef, no MSI url found')
            return
        LOG.debug('Downloading %s' % self._msi_url)
        filename, headers = urllib.urlretrieve(self._msi_url)
        try:
            self._install_msi(filename)
        finally:
            LOG.debug('Cleaning up %s' % filename)
            os.unlink(filename)

    @staticmethod
    def _remove_validation_cert():
        if os.path.exists(CHEF_VALIDATION_KEY):
            os.unlink(CHEF_VALIDATION_KEY)

    @staticmethod
    def _run_chef():
        if not os.path.exists(CHEF_COMMAND):
            LOG.debug('Not running chef, %s not found' % CHEF_COMMAND)
            return
        subprocess.check_call([RUBY_COMMAND, CHEF_COMMAND], shell=True)

    def execute(self, service, shared_data):
        self._node_name = self._get_node_name(service)
        self._server_url = self._get_user_data_value(service, 'chef_server_url', required=True)
        self._msi_url = self._get_user_data_value(service, 'msi_url', required=True)
        self._validation_client_name = self._get_user_data_value(service, 'validation_client_name')
        self._validation_cert = self._get_user_data_value(service, 'validation_cert')
        self._run_list = self._get_user_data_value(service, 'chef_run_list', default=[])
        self._environment = self._get_user_data_value(service, 'chef_environment')
        self._initial_attributes = self._get_user_data_value(service, 'initial_attributes')

        if self._server_url is None \
                or self._msi_url is None:
            LOG.warn('Required parameter missing')
            return base.PLUGIN_EXECUTE_ON_NEXT_BOOT, False

        #try:
        if True:
            self._write_validation_cert()
            self._write_chef_config()
            self._write_first_boot_json()
            installed = self._is_chef_installed()
            if not installed:
                    self._install_chef()
            self._run_chef()
        #finally:
        #    self._remove_validation_cert()
        return base.PLUGIN_EXECUTION_DONE, False
